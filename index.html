<!DOCTYPE html>
<html>
<head>
    <title>GAME</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta charset="UTF-8">
    <style>
        :root {
            --buttons-font-size: 15px;
            --buttons-line-height: calc(var(--buttons-font-size) * 1.2);
            --buttons-padding: 8px;
        }
        body {
            margin: 0;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background-color: black;
            height: 100vh;
            width: 100vw;
            gap: 15px;
            user-select: none;
        }
        #level {
            color: white;
            font-size: 15px;
        }
        #wrapper {
            position: relative;
        }
        #canvas {
            display: grid;
            --gap: 0.5px;
            gap: var(--gap);
            grid-template-columns: repeat(64, min(calc((100vw - var(--gap) * 63) / 64), 7.1px));
            grid-template-rows: repeat(64, min(calc((100vw - var(--gap) * 63) / 64), 7.1px));
            background-color: grey;
        }
        .filled {
            position: absolute;
            width: 100%;
            height: 100%;
            flex-direction: column;
            background-color: black;
            border: 2px solid purple;
            display: none;
            color: white;
            justify-content: center;
            align-items: center;
        }
        #gameover {
            font-size: 30px;
            gap: 20px;
        }
        #tryAgainButton {
            font-size: 20px;
            padding: 8px;
            border: 2px solid purple;
            color: white;
        }
        .pixel {
            width: min(calc((100vw - var(--gap) * 63) / 64), 7.1px);
            height: min(calc((100vw - var(--gap) * 63) / 64), 7.1px);
            background-color: darkgrey;
        }
        #buttons, #move {
            padding: 0px 15px;
            display: flex;
            flex-direction: row;
            gap: 10px;
        }
        #buttons div:not(#move), #move div {
            background-color: #262626;
            font-size: var(--buttons-font-size);
            line-height: var(--buttons-line-height);
            padding: var(--buttons-padding);
            border-radius: calc((var(--buttons-line-height) + var(--buttons-padding) * 2) / 2);
            color: white;
        }
        #move div {
            width: var(--buttons-line-height);
        }
        #buttons div.hover:not(#move), #move div.hover, #buttons div:hover:not(#move), #move div:hover {
            background-color: #444444;
        }
    </style>
</head>
<body>
    <span id="level"></span>
    <div id="wrapper">
        <div id="gameover" class="filled">
            GAME OVER
            <div id="tryAgainButton">Try Again</div>
        </div>
        <div id="canvas"></div>
    </div>
    <div id="buttons">
        <div id="move">
            <div id="up">↑</div>
            <div id="down">↓</div>
            <div id="left">←</div>
            <div id="right">→</div>
        </div>
        <div id="undo">Undo</div>
        <div id="tryAgain">Try Again</div>
    </div>
    <script>
        const canvas = document.getElementById('canvas');
        const pixelCount = 64 * 64;
        const level = 0;
        const levels = [];
        function pixels(index) {
            return [
                [
                    index,
                    index + 1,
                    index + 2,
                    index + 3
                ],
                [
                    index + 64,
                    index + 65,
                    index + 66,
                    index + 67
                ],
                [
                    index + 128,
                    index + 129,
                    index + 130,
                    index + 131
                ],
                [
                    index + 192,
                    index + 193,
                    index + 194,
                    index + 195
                ]
            ];
        }

        for (let i = 0; i < pixelCount; i++) {
            const pixel = document.createElement('div');
            pixel.classList.add('pixel');
            canvas.appendChild(pixel);
        }
        fetch('game.json')
            .then(response => response.json())
            .then(data => {
                levels.push(...data);
                levels.forEach((item, i) => {
                    item.remainingSteps = item.maxSteps; //启动关卡时配置步数
                    item.blocks.sort((a, b) => (b.type == 'p') - (a.type == 'p')); //让p块到最前面去
                    item.underControl = 1; //初始化
                    levels[i] = [item]; //变成数组成员再赋值给自己，从而变成嵌套数组，用于记录帧
                });
                drawFrame(false);
            });

        function drawFrame(redrawBG = true) {
            if (redrawBG) {
                Array.from(canvas.children).forEach(item => {
                    item.style.backgroundColor = 'darkgrey';
                });
            }
            document.getElementById('level').innerText = `LEVEL ${level + 1}/${levels.length}`;
            for (let i = 0; i < 64 * 2; i++) {
                canvas.children[i].style.backgroundColor = 'lightslategray';
            }
            for (let i = 0; i < Math.round(64 / levels[level][0].maxSteps * levels[level][0].remainingSteps); i++) {
                canvas.children[i].style.backgroundColor = 'orange';
            }
            for (let i = 0; i < 64 * 2; i++) {
                canvas.children[64 * (64 - 2) + i].style.backgroundColor = 'lightslategray';
            }
            for (let i = 0; i <= level; i++) {
                const width = Math.round((64 - levels.length) / (levels.length + 1));
                for (let j = 0; j < width; j++) {
                    canvas.children[64 * (64 - 1) + i * width + i + j].style.backgroundColor = 'forestgreen';
                }
            }
            levels[level][0].blocks.forEach((item) => {
                for (let i = 0; i < item.h; i++) {
                    for (let j = 0; j < item.w; j++) {
                        let index = ((item.y - 1 + i) * 4 + 2) * 64 + ((item.x - 1 + j) * 4);
                        pixels(index).forEach((p, yindex) => {
                            p.forEach((q, xindex) => {
                                canvas.children[q].style.backgroundColor = (() => {
                                    switch (item.hard?.corner) {
                                        case 'left-top':
                                            if (i < item.hard.h && j < item.hard.w && (xindex == 1 || xindex == 2) && (yindex == 1 || yindex == 2)) {
                                                return item.type == '1' ? 'black' : 'dimgray';
                                            }
                                            break;
                                        case 'left-bottom':
                                            if (item.h - i <= item.hard.h && j < item.hard.w && (xindex == 1 || xindex == 2) && (yindex == 1 || yindex == 2)) {
                                                return item.type == '1' ? 'black' : 'dimgray';
                                            }
                                            break;
                                        case 'right-top':
                                            if (i < item.hard.h && item.w - j <= item.hard.w && (xindex == 1 || xindex == 2) && (yindex == 1 || yindex == 2)) {
                                                return item.type == '1' ? 'black' : 'dimgray';
                                            }
                                            break;
                                        case 'right-bottom':
                                            if (item.h - i <= item.hard.h && item.w - j <= item.hard.w && (xindex == 1 || xindex == 2) && (yindex == 1 || yindex == 2)) {
                                                return item.type == '1' ? 'black' : 'dimgray';
                                            }
                                            break;
                                        case undefined:
                                            break;
                                    }
                                    switch (item.type) {
                                        case '1': return 'deeppink';
                                        case '2': return 'aqua';
                                        case '3': return 'yellow';
                                        case '4': return 'blue';
                                        case '5': return 'green';
                                        case '6': return 'red';
                                        case 'p': return (xindex + yindex + 1) % 2 ? 'papayawhip' : 'navajowhite';
                                    }
                                })();
                            });
                        });
                    }
                }
            });
        }

        function updateRemainingSteps() {
            levels[level].unshift(JSON.parse(JSON.stringify(levels[level][0])));
            levels[level][0].remainingSteps--;
            for (let i = 0; i < 64 / levels[level][0].maxSteps; i++) {
                canvas.children[Math.round(64 / levels[level][0].maxSteps * levels[level][0].remainingSteps) + i].style.backgroundColor = 'lightslategray';
            }
        }

        function getControl() {
            return levels[level][0].blocks.find(item => item.type == levels[level][0].underControl);
        }

        function check() {
            if (!Array.from(canvas.children).some((item, index) => (index - 64 * 2) % 4 == 0 && Math.floor((index - 64 * 2) / 64) % 4 == 0 && item.style.backgroundColor == 'papayawhip')) {
                if (level != levels.length - 1) {
                    level++;
                    drawFrame();
                } else {

                }
                return;
            }
            if (levels[level][0].remainingSteps == 0) {
                document.getElementById('gameover').style.display = 'flex';
                document.getElementById('buttons').style.visibility = 'hidden';
            }
        }

        function up() {
            let control = getControl();
            if ((control.hard.corner == 'left-top' || control.hard.corner == 'right-top') && control.h != control.hard.h) {
                updateRemainingSteps();
                control = getControl(); //更新
                control.h--;
                for (let i = 0; i < control.w; i++) {
                 pixels(((control.y - 1 + control.h) * 4 + 2) * 64 + (control.x - 1 + i) * 4).forEach((p, yindex) => {
                        p.forEach((q, xindex) => {
                            if (levels[level][0].blocks.filter(item => item.type == 'p')
                                .some(item => item.x <= control.x + i && control.x + i <= item.x + item.w - 1 && item.y <= control.y + control.h && control.y + control.h <= item.y + item.h - 1)) {
                                canvas.children[q].style.backgroundColor = (xindex + yindex + 1) % 2 ? 'papayawhip' : 'navajowhite';
                            } else {
                                canvas.children[q].style.backgroundColor = 'darkgrey';
                            }
                        });
                    });
                }
            } else if (levels[level][0].blocks.every(item => item.type == 'p' || !((control.y - 1 >= item.y && control.y - 1 <= item.y + item.h - 1)
                && (item.x < control.x + control.w && control.x < item.x + item.w))) && control.y != 1) {
                if (control.hard.corner == 'left-top') {
                    control.hard.corner = 'left-bottom';
                } else if (control.hard.corner == 'right-top') {
                    control.hard.corner = 'right-bottom';
                }
                updateRemainingSteps();
                control = getControl(); //更新
                control.y--;
                control.h++;
                for (let i = 0; i < control.w; i++) {
                    pixels(((control.y - 1) * 4 + 2) * 64 + (control.x - 1 + i) * 4).forEach(p => {
                        p.forEach(q => {
                            canvas.children[q].style.backgroundColor = (() => {
                                switch (control.type) {
                                    case '1': return 'deeppink';
                                    case '2': return 'aqua';
                                    case '3': return 'yellow';
                                    case '4': return 'blue';
                                    case '5': return 'green';
                                    case '6': return 'red';
                                }
                            })();
                        });
                    });
                }
            }
        }

        function down() {
            let control = getControl();
            if ((control.hard.corner == 'left-bottom' || control.hard.corner == 'right-bottom') && control.h != control.hard.h) {
                updateRemainingSteps();
                control = getControl(); //更新
                control.h--;
                control.y++;
                for (let i = 0; i < control.w; i++) {
                    pixels(((control.y - 2) * 4 + 2) * 64 + (control.x - 1 + i) * 4).forEach((p, yindex) => {
                        p.forEach((q, xindex) => {
                            if (levels[level][0].blocks.filter(item => item.type == 'p')
                                .some(item => item.x <= control.x + i && control.x + i <= item.x + item.w - 1 && item.y <= control.y - 1 && control.y - 1 <= item.y + item.h - 1)) {
                                canvas.children[q].style.backgroundColor = (xindex + yindex + 1) % 2 ? 'papayawhip' : 'navajowhite';
                            } else {
                                canvas.children[q].style.backgroundColor = 'darkgrey';
                            }
                        });
                    });
                }
            } else if (levels[level][0].blocks.every(item => item.type == 'p' || !((control.y + control.h >= item.y && control.y + control.h <= item.y + item.h - 1) 
                       && (item.x < control.x + control.w && control.x < item.x + item.w))) && control.y + (control.h - 1) != 15) {
                if (control.hard.corner == 'left-bottom') {
                    control.hard.corner = 'left-top';
                } else if (control.hard.corner == 'right-bottom') {
                    control.hard.corner = 'right-top';
                }
                updateRemainingSteps();
                control = getControl(); //更新
                for (let i = 0; i < control.w; i++) {
                    pixels(((control.y + control.h - 1) * 4 + 2) * 64 + (control.x - 1 + i) * 4).forEach(p => {
                        p.forEach(q => {
                            canvas.children[q].style.backgroundColor = (() => {
                                switch (control.type) {
                                    case '1': return 'deeppink';
                                    case '2': return 'aqua';
                                    case '3': return 'yellow';
                                    case '4': return 'blue';
                                    case '5': return 'green';
                                    case '6': return 'red';
                                }
                            })();
                        });
                    });
                }
                control.h++;
            }
        }

        function left() {
            let control = getControl();
            if ((control.hard.corner == 'left-bottom' || control.hard.corner == 'left-top') && control.w != control.hard.w) {
                updateRemainingSteps();
                control = getControl(); //更新
                control.w--;
                for (let i = 0; i < control.h; i++) {
                    pixels(((control.y - 1 + i) * 4 + 2) * 64 + (control.x + control.w - 1) * 4).forEach((p, yindex) => {
                        p.forEach((q, xindex) => {
                            if (levels[level][0].blocks.filter(item => item.type == 'p')
                                .some(item => item.x <= control.x + control.w && control.x + control.w <= item.x + item.w - 1 && item.y <= control.y + i  && control.y + i <= item.y + item.h - 1)) {
                                canvas.children[q].style.backgroundColor = (xindex + yindex + 1) % 2 ? 'papayawhip' : 'navajowhite';
                            } else {
                                canvas.children[q].style.backgroundColor = 'darkgrey';
                            }
                        });
                    });
                }
            } else if (levels[level][0].blocks.every(item => item.type == 'p' || !((control.x - 1 >= item.x && control.x - 1 <= item.x + item.w - 1)
                       && (item.y < control.y + control.h && control.y < item.y + item.h))) && control.x != 1) {
                if (control.hard.corner == 'left-bottom') {
                    control.hard.corner = 'right-bottom';
                } else if (control.hard.corner == 'left-top') {
                    control.hard.corner = 'right-top';
                }
                updateRemainingSteps();
                control = getControl(); //更新
                control.x--;
                control.w++;
                for (let i = 0; i < control.h; i++) {
                    pixels(((control.y + i - 1) * 4 + 2) * 64 + (control.x - 1) * 4).forEach(p => {
                        p.forEach(q => {
                            canvas.children[q].style.backgroundColor = (() => {
                                switch (control.type) {
                                    case '1': return 'deeppink';
                                    case '2': return 'aqua';
                                    case '3': return 'yellow';
                                    case '4': return 'blue';
                                    case '5': return 'green';
                                    case '6': return 'red';
                                }
                            })();
                        });
                    });
                }
            }
        }

        function right() {
            let control = getControl();
            if ((control.hard.corner == 'right-bottom' || control.hard.corner == 'right-top') && control.w != control.hard.w) {
                updateRemainingSteps();
                control = getControl(); //更新
                control.x++;
                control.w--;
                for (let i = 0; i < control.h; i++) {
                    pixels(((control.y - 1 + i) * 4 + 2) * 64 + (control.x - 2) * 4).forEach((p, yindex) => {
                        p.forEach((q, xindex) => {
                            if (levels[level][0].blocks.filter(item => item.type == 'p')
                                .some(item => item.x <= control.x - 1 && control.x - 1 <= item.x + item.w - 1 && item.y <= control.y + i && control.y + i <= item.y + item.h - 1)) {
                                canvas.children[q].style.backgroundColor = (xindex + yindex + 1) % 2 ? 'papayawhip' : 'navajowhite';
                            } else {
                                canvas.children[q].style.backgroundColor = 'darkgrey';
                            }
                        });
                    });
                }
            } else if (levels[level][0].blocks.every(item => item.type == 'p' || !((control.x + control.w >= item.x && control.x + control.w <= item.x + item.w - 1) 
                       && (item.y < control.y + control.h && control.y < item.y + item.h))) && control.x + (control.w - 1) != 16) {
                if (control.hard.corner == 'right-bottom') {
                    control.hard.corner = 'left-bottom';
                } else if (control.hard.corner == 'right-top') {
                    control.hard.corner = 'left-top';
                }
                updateRemainingSteps();
                control = getControl(); //更新
                control.w++;
                for (let i = 0; i < control.h; i++) {
                    pixels(((control.y + i - 1) * 4 + 2) * 64 + (control.x + control.w - 2) * 4).forEach(p => {
                        p.forEach(q => {
                            canvas.children[q].style.backgroundColor = (() => {
                                switch (control.type) {
                                    case '1': return 'deeppink';
                                    case '2': return 'aqua';
                                    case '3': return 'yellow';
                                    case '4': return 'blue';
                                    case '5': return 'green';
                                    case '6': return 'red';
                                }
                            })();
                        });
                    });
                }
            }
        }

        document.addEventListener('keydown', (e) => {
            if (document.getElementById('buttons').style.visibility == 'hidden') {
                return;
            }
            switch (e.key) {
                case 'ArrowUp':
                    up();
                    document.getElementById('up').classList.add('hover');
                    break;
                case 'ArrowDown': 
                    down();
                    document.getElementById('down').classList.add('hover');
                    break;
                case 'ArrowLeft':
                    left();
                    document.getElementById('left').classList.add('hover');
                    break;
                case 'ArrowRight':
                    right();
                    document.getElementById('right').classList.add('hover');
                    break;
            }
            check();
        });
        document.addEventListener('keyup', (e) => {
            switch (e.key) {
                case 'ArrowUp':
                    document.getElementById('up').classList.remove('hover');
                    break;
                case 'ArrowDown': 
                    document.getElementById('down').classList.remove('hover');
                    break;
                case 'ArrowLeft':
                    document.getElementById('left').classList.remove('hover');
                    break;
                case 'ArrowRight':
                    document.getElementById('right').classList.remove('hover');
                    break;
            }
        });
        document.getElementById('up').addEventListener('click', () => {
            up();
            check();
        });
        document.getElementById('down').addEventListener('click', () => {
            down();
            check();
        });
        document.getElementById('left').addEventListener('click', () => {
            left();
            check();
        });
        document.getElementById('right').addEventListener('click', () => {
            right();
            check();
        });
        document.getElementById('undo').addEventListener('click', () => {
            if (levels[level].length != 1) {
                levels[level].shift();
                drawFrame();
            }
        });
        document.getElementById('tryAgain').addEventListener('click', () => {
            levels[level] = [levels[level].at(-1)];
            drawFrame();
        });
        document.getElementById('tryAgainButton').addEventListener('click', () => {
            levels[level] = [levels[level].at(-1)];
            drawFrame();
            document.getElementById('gameover').style.display = 'none';
            document.getElementById('buttons').style.visibility = 'visible';
        });
    </script>
</body>
</html>



























